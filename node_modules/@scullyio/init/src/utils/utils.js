"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@angular-devkit/core");
const schematics_1 = require("@angular-devkit/schematics");
const ast_utils_1 = require("@schematics/angular/utility/ast-utils");
const typescript_1 = require("@schematics/angular/third_party/github.com/Microsoft/TypeScript/lib/typescript");
const find_module_1 = require("@schematics/angular/utility/find-module");
const js_yaml_1 = require("js-yaml");
const DEFAULT_PACKAGE_JSON_PATH = '/package.json';
const DEFAULT_ANGULAR_CONF_PATH = '/angular.json';
const DEFAULT_NX_CONF_PATH = '/workspace.json';
function addRouteToScullyConfig(scullyConfigJs, data) {
    const baseRoute = core_1.strings.dasherize(data.route);
    const completeRoute = core_1.normalize(`/${baseRoute}/:${core_1.strings.camelize(data.slug)}`);
    const contentDirectoy = data.sourceDir ? core_1.strings.dasherize(data.sourceDir) : core_1.strings.dasherize(data.name);
    const addRoute = `\n    '${completeRoute}': {
      type: '${data.type}',
      ${core_1.strings.camelize(data.slug)}: {
        folder: ".${core_1.normalize('/' + contentDirectoy)}"
      }
    },`;
    let output;
    if (+scullyConfigJs.search(/routes: \{/g) > 0) {
        const position = +scullyConfigJs.search(/routes: \{/g) + 'routes: {'.length;
        output = [scullyConfigJs.slice(0, position), addRoute, scullyConfigJs.slice(position)].join('');
    }
    else if (+scullyConfigJs.search(/routes:\{/g) > 0) {
        const position = +scullyConfigJs.search(/routes:\{/g) + 'routes:{'.length;
        output = [scullyConfigJs.slice(0, position), addRoute, scullyConfigJs.slice(position)].join('');
    }
    else {
        return scullyConfigJs;
    }
    return output;
}
exports.addRouteToScullyConfig = addRouteToScullyConfig;
function addTypescriptFolder(scullyConfigJs, data) {
    const addRoute = `${data},\n`;
    let output;
    if (+scullyConfigJs.search(/outDir:/g) > 0) {
        const position = +scullyConfigJs.search(/outDir:/g);
        output = [scullyConfigJs.slice(0, position), addRoute, scullyConfigJs.slice(position)].join('');
    }
    else {
        return scullyConfigJs;
    }
    return output;
}
exports.addTypescriptFolder = addTypescriptFolder;
function applyWithOverwrite(source, rules) {
    return (tree, context) => {
        const rule = schematics_1.mergeWith(schematics_1.apply(source, [
            ...rules,
            schematics_1.forEach((fileEntry) => {
                if (tree.exists(fileEntry.path)) {
                    tree.overwrite(fileEntry.path, fileEntry.content);
                    return null;
                }
                return fileEntry;
            }),
        ]));
        return rule(tree, context);
    };
}
exports.applyWithOverwrite = applyWithOverwrite;
function getPrefix(host, project, angularjsonPath) {
    return getProjectProperty(host, ['prefix'], project, angularjsonPath);
}
exports.getPrefix = getPrefix;
function addRouteToModule(host, options) {
    const srcFolder = getSrc(host, exports.getProject(host, options.project));
    let path = `${srcFolder}/app/app-routing.module.ts`;
    if (!host.exists(path)) {
        path = `${srcFolder}/app/app.module.ts`;
    }
    const text = host.read(path);
    if (!text) {
        throw new Error(`Couldn't find the module nor its routing module.`);
    }
    const sourceText = text.toString();
    const addDeclaration = ast_utils_1.addRouteDeclarationToModule(typescript_1.createSourceFile(path, sourceText, typescript_1.ScriptTarget.Latest, true), path, buildRoute(options, 'app.module', options.route));
    const recorder = host.beginUpdate(path);
    recorder.insertLeft(addDeclaration.pos, addDeclaration.toAdd);
    host.commitUpdate(recorder);
}
exports.addRouteToModule = addRouteToModule;
function buildRoute(options, modulePath, route) {
    const relativeModulePath = buildRelativeModulePath(options, modulePath);
    const moduleName = `${core_1.strings.classify(options.name)}Module`;
    const loadChildren = `() => import('${relativeModulePath}').then(m => m.${moduleName})`;
    const basePath = route ? core_1.strings.dasherize(route) : core_1.strings.dasherize(options.name);
    return `{ path: '${basePath}', loadChildren: ${loadChildren} }`;
}
function buildRelativeModulePath(options, modulePath) {
    const dasherized = core_1.strings.dasherize(options.name);
    const importModulePath = core_1.normalize(`/${dasherized}/${dasherized}.module`);
    return find_module_1.buildRelativePath(modulePath, importModulePath);
}
function getSrc(host, project, angularjsonPath) {
    return getProjectProperty(host, ['sourceRoot'], project, angularjsonPath);
}
exports.getSrc = getSrc;
function getRoot(host, project, angularjsonPath) {
    return getProjectProperty(host, ['root'], project, angularjsonPath);
}
exports.getRoot = getRoot;
function getStyle(host, project, angularjsonPath) {
    return getProjectProperty(host, ['schematics', '@schematics/angular:component', 'style'], project, angularjsonPath);
}
exports.getStyle = getStyle;
/* Don't check if the file exists
 */
function getProjectProperty(host, propertyPath, project = '', angularjsonPath = DEFAULT_ANGULAR_CONF_PATH) {
    let angularConfig;
    try {
        angularConfig = parseJsonObject(host.read(angularjsonPath).toString());
    }
    catch (e) {
        angularConfig = parseJsonObject(host.read(DEFAULT_NX_CONF_PATH).toString());
    }
    project = project.trim();
    if (!project || project === 'defaultProject') {
        project = angularConfig.defaultProject;
    }
    if (project === undefined) {
        throw new Error(`The angular.json file don't have the property 'defaultProject', please run
'ng/nx add @scullyio/init' again with '--project=<<project_name>>' and add the name of your project`);
    }
    const projectConfig = angularConfig.projects[project];
    if (projectConfig === undefined) {
        throw new Error(`The angular.json file don't have the property sourceRoot.
Scully need the value for work.
Please add into your angular.json:
...
"projects": {
    "${project}": {
        "sourceRoot": "<<app_source_root>>",

...`);
    }
    return propertyPath.slice(0).reduce((v, item, i, pp) => {
        if (v[item] === undefined) {
            pp.splice(1);
        }
        return v[item];
    }, projectConfig);
}
/** Parser of json content
 *  By default allow Json5 syntax, eg comments, trailing commas, ..., ie the same
 *  thing that the Angular json parser itself.
 *
 *  !!! You should always replace JSON.parse by this function !!!
 */
function parseJsonObject(jsonContent, mode = core_1.JsonParseMode.Loose) {
    const result = core_1.parseJson(jsonContent, mode);
    if (result === null || typeof result !== 'object' || Array.isArray(result)) {
        throw new Error('Json content is not an object');
    }
    return result;
}
exports.parseJsonObject = parseJsonObject;
class FileNotFoundException extends Error {
    constructor(fileName) {
        const message = `File ${fileName} not found!`;
        super(message);
    }
}
/** Parser of json file
 *
 *  By default allow only strict json syntax
 *
 */
exports.getJsonFile = (tree, path, mode = core_1.JsonParseMode.Json) => {
    const file = tree.get(path);
    if (!file) {
        throw new FileNotFoundException(path);
    }
    try {
        const content = parseJsonObject(file.content.toString(), mode);
        return content;
    }
    catch (e) {
        throw new schematics_1.SchematicsException(`File ${path} could not be parsed!`);
    }
};
exports.getFileContents = (tree, filePath) => {
    const buffer = tree.read(filePath) || '';
    return buffer.toString();
};
/** Parser of package.json file
 *
 *  Allow only strict json content
 *
 */
exports.getPackageJson = (tree, packagejsonPath = DEFAULT_PACKAGE_JSON_PATH) => {
    return exports.getJsonFile(tree, packagejsonPath);
};
exports.overwritePackageJson = (tree, content, packagejsonPath = DEFAULT_PACKAGE_JSON_PATH) => {
    tree.overwrite(packagejsonPath, JSON.stringify(content, null, 2));
    return tree;
};
function getSourceFile(host, path) {
    const file = host.get(path);
    if (!file) {
        throw new FileNotFoundException(path);
    }
    const content = file.content.toString();
    const source = typescript_1.createSourceFile(path, content, typescript_1.ScriptTarget.Latest, true);
    return source;
}
exports.getSourceFile = getSourceFile;
exports.yamlToJson = (host, filePath) => {
    const file = host.get(filePath);
    if (!file) {
        throw new FileNotFoundException(filePath);
    }
    const metaDataContents = file.content.toString();
    try {
        return js_yaml_1.safeLoad(metaDataContents);
    }
    catch (e) {
        throw new schematics_1.SchematicsException(`${filePath} contains invalid yaml`);
    }
};
exports.jsonToJaml = (metaData) => js_yaml_1.safeDump(metaData);
exports.toAscii = (src) => {
    if (!src) {
        return null;
    }
    // tslint:disable-next-line:one-variable-per-declaration
    let ch, str, i, result = '';
    str = JSON.stringify(src);
    for (i = 1; i < str.length - 1; i++) {
        ch = str.charCodeAt(i);
        // 0-9 A-Z a-z
        if ((ch >= 48 && ch <= 57) || (ch >= 65 && ch <= 90) || (ch >= 97 && ch <= 122)) {
            result += str.charAt(i);
        }
    }
    return result;
};
exports.getProject = (host, project, angularjsonPath = DEFAULT_ANGULAR_CONF_PATH) => {
    let angularJson;
    if (project === 'defaultProject') {
        try {
            angularJson = parseJsonObject(host.read(angularjsonPath).toString());
        }
        catch (e) {
            angularJson = parseJsonObject(host.read(DEFAULT_NX_CONF_PATH).toString());
        }
        return angularJson.defaultProject;
    }
    return project;
};
exports.getScullyConfig = (host, project) => {
    const scullyConfigFile = `scully.${exports.getProject(host, project)}.config.ts`;
    return scullyConfigFile;
};
exports.checkProjectExist = (host, project = '', angularjsonPath = DEFAULT_ANGULAR_CONF_PATH) => {
    let angularJson;
    try {
        angularJson = parseJsonObject(host.read(angularjsonPath).toString());
    }
    catch (e) {
        angularJson = parseJsonObject(host.read(DEFAULT_NX_CONF_PATH).toString());
    }
    return angularJson.projects[project] !== undefined;
};
exports.removeWrongCharacters = (str) => {
    return str.replace(/\{|\}|\(|\)|\;/g, '');
};
//# sourceMappingURL=utils.js.map